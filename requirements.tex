

\section{Thoughts on Unifying Modeling and Programming}
\label{sec:concerns}

In this section we shall try to summarize our views on 
unifying modeling and programming.
A unified modeling and programming framework has to satisfy 
quite different and contradicting goals.
First of all, it has to represent the concepts of the 
application domain at an adequate level of 
abstraction such that the specialities of the applications 
are directly represented and not covered by awkward implementation 
concepts. This may for example include support for user-defined 
extensions of the language with domain-specific languages (DSLs). 
Second it has to address the structuring of algorithms and data 
structures in a way such that programs stay understandable, 
modular and support the most important methods of structured 
program development. And finally it has to allow addressing 
specific implementation properties of execution machines including 
their operating systems, such that it can be controlled how the 
implementation uses resources and exploits the possibilities of 
the execution platform and its hardware. An obvious problem here 
of course is to what extent then the particular application domain 
influences the programming language, and to what extent this 
is true for the execution platform and efficiency concerns as
well. In this section we shall try to outline what we see as the 
concerns that need to be addressed in any attempt to unify the 
view of modeling and 
programming.

\subsubsection{Wide target}We can observe three major domains of interest, namely modeling; 
programming of non-embedded systems, such as web applications, 
including scripting; and finally programming of embedded/cyber-
physical systems. It is clear that these three domains till date 
have been addressed by different communities and different 
languages, as outlined above. The question is to what extent these
quite different domains could be targeted with the same formalism.
Note that the different modeling and programming languages used on
different targets have an overwhelming number of language constructs in
common, to an extent where this question at least needs to be answered
in a scientific manner rather than in an opinionated emotional manner.

\subsubsection{Specification of `what' rather than `how'}This generally means support for specifying properties as predicates
rather than algorithms. Predicate-oriented techniques include
design-by-contract, including pre- and post-conditions, as well 
as class invariants. Such can for example be found in Eiffel as 
well as in SPARK. This concept that it can be carried 
further to for example include behavioral sequence specification, 
such as temporal logics, sequence diagrams, etc.
Note, however, that many models are very operational in
nature, and hence can very well best be formulated as state machines,
or programs (data structures and algorithms). 

\subsubsection{Development in the large}Large models/programs have to be structured. They have to be structured on 
one hand in independent or at least rather independent pieces that 
can be reused, independently changed, translated and executed on 
different hardware, such that a flexible deployment is achieved. 
They have to offer appropriate techniques for encapsulation and 
parameterization. This structuring may also address issues of 
execution such as deployment and parallel execution.What is needed, in particular, is an appropriate notion of 
component as a unit of modularity and encapsulation. Such concepts 
exist in a lot of programming languages. However since most of the 
programming languages we are using today are inherently sequential, 
an independent deployment and execution model often is not directly 
achieved.A key to efficient software evolution is the identification of 
components that can be used and reused at several places in a 
program. This requires a sufficient amount of variability. If such 
variability cannot be achieved then code cannot be reused at many 
places and as a result we have to form clones, meaning similar 
pieces of code with just small differences, such that they can be 
used at the individual places. Another issue for variability is the 
usage of different variations of software in the context of 
software families. Variability is an important concept, which is 
not very much supported explicitly by nowadays programming 
languages.

\subsubsection{Support for high-level programming}The specification, design, and implementation notation has to be 
sufficiently abstract. Many formalisms used and suggested for that 
including a lot of the programming languages force the programmers 
to write too many details enforcing a particular style, which is 
related to a way to describe algorithms. Therefore the resulting 
programs get very long and more difficult to understand. The key 
question is how to provide programming concepts that are 
expressive, understandable, and do not enforce the explicit 
formulation of a lot of details due to a particular algorithmic 
style.The elegance and the implicitly of functional programs have been 
praised many times. Nevertheless they never had an absolute 
breakthrough. In contrast, object oriented programming languages, 
which in particular address encapsulation and reuse were very 
successful. They provide entities of implementation called classes, 
which at the same time are able to present concepts in the 
application domain and units of execution. However, for all 
nowadays object oriented programming languages there are a number 
of properties, which do not allow using them in the required 
universal modelling style. One reason for that is that object 
oriented programming languages are inherently sequential due to 
their remote procedure call concept. All attempts to provide 
parallel execution models such as threads make things ugly and very 
complex. Therefore a good idea would be to use many of the good 
ideas in object oriented and functional programming and bringing 
them together in powerful generalizations. A language such as Scala 
has made this attempt, and even early versions of LISP had this 
(CLOS). Functional programming means for example functions as 
values (lambda abstractions) and pattern matching, and of course 
reliance on recursion. Functional programming is by some considered 
the best approach to use multi-core systems due to no shared state 
updates.Perhaps specialized notation for collections as in Fortress (very similar 
to VDM), or as libraries. Easy ways of iterating through 
collections – to avoid indexing problems for example. Support for 
parallel computation over such.

\subsubsection{Domain-specific data modeling}A key to programming is to capture the relevant concept of the 
application domain and to present them in the specification design 
and implementation notation. This is exactly where UML and also 
SysML are quite successful. They provide a number of concepts which 
originally were created in the area of programming and good enough 
to allow presenting quite a number of application domain issues. A 
typical examples are class style diagrams, which at a level of 
programming are describing more or less architectures in terms of 
classes and how they are connected, but can also be used as 
possibilities to describe data models and finally ontologies as we 
find them under the heading of meta models. In any case it is 
important to support powerful modelling approaches in the 
specification, design and implementation notation.

\subsubsection{Typing and physical dimensions}We believe a language should be largely statically typed. It can 
potentially allow for going type-less in clearly defined regions, 
in case such makes modeling and programming easier. Scripting 
languages are popular, in part because they are type-less. It would 
be interesting to see if one could allow both approaches to be used 
within the same language. Otherwise decades of experience in strong 
type systems should of course be harvested, including more recent 
topics such as dependent types, session types, and units.

\subsubsection{Support for low-level programming}Embedded programing these days often means: no dynamic memory 
allocation after initialization, no garbage collection, some 
knowledge of memory layout, even to the point where computation 
with addresses is used to improve speed. This again means use of 
low level programming languages such as C. C, however, allows for 
memory errors and makes programmers less effective as they would 
otherwise be were they allowed to program in higher-level 
languages. We need to satisfy the needs encountered by typical C 
programmers, including offering comparable speed and memory 
control. This includes support for hardware control.

\subsubsection{Concurrency}Concurrency is an essential part of modern programming, especially 
considering the emergence of multi-core computers. However, 
concurrency is important at the modeling level as well, where it 
can serve as a natural way to describe interacting agents. 
Important concepts include agent systems, message passing based 
communication, parallel data structures (programming concurrent 
without knowing it), and distributed programming.

\subsubsection{Execution model}The programming notation has to allow to control execution aspects. 
Often in today’s practice, extensions are introduced that allow 
controlling execution platforms. This is important in order to 
provide programs that are efficient. On the other hand, it is very 
dangerous since it mixes up domain specific concepts,  data 
modelling, and algorithms on one hand, and issues of specific 
execution concepts of the execution platform. Such a mix also makes 
it very difficult to port and migrate software. A promising 
approach could be that the specification, design, and 
implementation notation provides possibilities to target a specific 
execution platform by separate profiles that are in addition to the 
description of the domain specific concepts in the algorithms. This 
idea could be applied for time, concurrency, deployment and 
distribution.


\subsubsection{Visualization}

Visualization is of extreme importance, as demonstrated by the relative success of
formalisms such as UML and SysML in the engineering community, when compared 
to formal methods textual notations. People generally are more at ease looking at
a 2-dimensional illustration when they encounter a problem specification for the first
time, and it eases communication. Whether visualization is useful as well for entering
and maintaining specifications is another matter. We do believe that visualization and 
text should match up, such that modification of one leads to immediate change in the 
other. Visualization is normally static, in the sense that it is models that are 
visualized. However, visualization can also be dynamic, of program executions, 
illustrating how behavior evolves.

\subsubsection{Analysis}A key concept in a combined modeling and programming environment is 
the support for advanced analysis of models/programs, including, 
but also beyond, what is normally supported in standard programming 
environments. This ranges from basic built-in support for unit 
testing, over advanced testing capabilities, including test input 
generation and monitoring, to concepts such as static analysis, 
model checking, theorem proving and symbolic execution. A core 
requirement, however, must be the practicality of these solutions. 
The main emphasis should be put on automation. The average user 
should be able to benefit from automated verification, without 
having to do manual proofs. However, support for manual theorem 
proving should also be possible, for example for core critical 
algorithms. Integration of static and dynamic analysis will be 
desirable: verify what is practically feasible, and test (monitor) 
the remaining proof obligations.


