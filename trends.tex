
\section{Trends in Modeling and Programming}
\label{sec:trends}

In this section we briefly survey some trends in the fields of
formal methods, model-based engineering, and programming, that we find worthwhile highlighting.

\subsection{Formal Methods}Early work on formal methods include the work of John McCarthy 
({\em Recursive Functions of Symbolic Expressions and Their 
Computation by Machines} \cite{Mc60} and 
{\em Towards a Mathematical Science of Computation} \cite{Mc62a}), 
Robert Floyd ({\em Assigning Meanings to Programs} \cite{Flo67}), 
Edsger Dijkstra ({\em A Discipline of Programming} \cite{EWD1}), 
Tony Hoare ({\em An Axiomatic Basis for Computer Programming} 
\cite{Hoa69}), and Dana Scott and Christopher 
Strachey ({\em Towards a Mathematical Semantics for Computer 
Languages} \cite{Sco71}), to mention a few. These ideas were 
theoretic in nature and deeply influential. They brought us the 
ideas of  annotating programs with assertions, such as pre- and 
post-conditions, and invariants, correct by construction 
development (refinement), and giving semantics to programming 
languages. 
These ideas were subsequently the basis for several, what we could 
call, second generation formal specification languages such as 
VDM 
\cite{vdm78,bjoerner-jones-82,jones90,jones-shaw-90},  
\vdmpp{} \cite{vdmplusplus05},
Z \cite{Spivey-Z-92}, B and Event-B \cite{abrial-eventb-10}, CIP 
\cite{cip-1985}, TLA \cite{lamport-TLA-1994}, RAISE 
%\cite{raise92,george-raise-2008,havelund-losl-08}, 
\cite{raise92,george-raise-2008},
and OBJ 
\cite{futatsugi-obj-1985}, to mention just a few. Each of these 
languages were full 
specification languages, most with rich type systems and detailed 
rules (grammars) for what constitutes a valid specification. These 
languages were ahead of their time wrt. language features in the 
sense that many of these features have found their 
way into modern programming languages of today. A particular
example of this is collections (sets, lists, and maps).The VDM language for example is a wide-spectrum specification 
language offering a combination of high-level specification 
constructs and low level programming like constructs. The 
methodology 
consists in part, as in CIP, of refining a high-level specification 
into a low-level program like specification in a stepwise manner. 
The language offered concepts 
such as the combination of imperative (procedural and later 
object-oriented in \vdmpp) and functional programming; exceptions; 
algebraic data types and pattern matching; functions as values and 
lambda abstractions; built-in collection types such as sets, lists 
and maps, with mathematical notation for creating values of these 
types, such as for example set comprehension; design-by-contract 
through pre- and post conditions and invariants; predicate subtypes 
(so one for example can define natural numbers as a subset of the 
integers);  and predicate logic including universal and existential 
quantification over any type as Boolean expressions.  VDM and Z are 
so-called {\em model oriented} specification languages, 
meaning that a specification is an example model of the desired system. This means that such specifications are somewhat close to high-level programs. This is in contrast to so-called {\em property oriented} (algebraic) specification languages, such as OBJ, where a specification denotes a set of models\footnote{This characteristic of the difference is somewhat simplified since a VDM specification in fact also can denote more than one model.}.  A different branch of formal methods includes theorem proving and 
model checking. In theorem proving we have seen specification 
languages, which resemble functional programming languages, 
including for example Isabelle \cite{isabelle}, PVS \cite{pvs}, and Coq \cite{coq}. In model checking, early 
work focused on modeling notations somewhat removed from 
programming languages. However, recent research has focused on 
software model checking, where the target of model checking is 
code, as for example seen in the Java PathFinder model checker 
(JPF) \cite{havelund-jpf-00,havelund-visser02}. JPF was created due 
to the observation that a powerful 
programming language might be a better modeling language than the 
traditional model checker input languages. Today’s 
efforts in model checking furthermore include numerous efforts in 
model checking of C programs.As can be seen from the above discussion, formal specification 
languages have for a long time been flirting with programming 
language like notations, and vice versa. However, the two classes of languages have by tradition been considered as belonging to 
strictly separate categories. VDM for example was always, and still 
is, considered a specification language, albeit with code 
generation capabilities. It has never, in spite of the possibility, 
been named a programming language, which one may 
consider being as one of the reasons it is not more wide spread. 
Writing specifications in VDM and generating code in Java, for 
example, has not become popular. Programmers feel uncomfortable 
working with two languages (a specification language and  a 
programming language) when the two languages are too similar. This 
is an argument for merging the concepts into a  specification, 
design and implementation language.

\subsection{Model-based Engineering}Model-based engineering includes modeling frameworks that are 
usually visual/graphical of nature. One of the main contributions 
in this field is UML \cite{uml} for software development, and its 
derivatives, such as SysML \cite{sysml} for systems development. 
The graphical nature of the 
UML family of languages has caused it to become rather popular and 
wide-spread in engineering communities. Engineers are more willing 
to work with graphical notations, such as 
class diagrams and state machines, than they are working with sets, 
lists and maps and function definitions. It seems clearly more 
accepted than formal methods as described in the previous section. 
%At JPL for example, there are three people working with formal 
%methods and over hundred working with UML/SysML technology. One of the important notations in UML/SysML is class diagrams. 
Class diagrams are, just like E/R-diagrams, really a simple way 
of defining data, an alternative to working with sets, lists and 
maps as found in VDM and modern programming languages. For example, 
to state that a person can own zero or more cars one draws a box 
for Person, and a box for Car, and draws a line between them. It is 
an idea that quickly can be picked up by a systems engineer, 
quicker than learning to use programming language data structures. 
Another notation is that of state 
machines, a concept that interestingly enough has not found its way 
into programming languages, in spite of its usefulness in 
especially embedded programming. UML and SysML also support 
requirements (as special comments), a concept that usually is not embedded as a first citizen in programming. 
%It would be interesting to see requirements as part of programming.The above observations are rather positive. However, UML and
SysML are very complex and weakly defined formalisms. 
For example, the combined syntax for all of UML corresponds 
to the sum of approximately 20 programming languages (approximately 
17,000 lines of abstract syntax, a programming language can 
normally be defined in between 500 and 2500 lines of grammar 
rules). The UML/SysML standards are long and complex documents. 
Furthermore, the connection between models and code is fragile, relying on the correctness of translators from for example UML state machines to code. Finally, a discussion about semantics
(what do two boxes with a line in between mean?) can turn 
a project meeting into chaos.


\subsection{Programming}Several new programming languages have emerged over the last 
decades, which include abstraction mechanisms known from the formal 
specification languages mentioned above. Such languages include 
Eiffel, Java, Python, Scala, Julia, Fortress,  C\#, Spec\#, F\#,  Dafny, D, 
RUST, Swift, Go, Agda, and SPARK.  Some languages support 
design-by-contract with pre-post conditions, and in some cases with 
invariants. These languages  include for example Eiffel, Spec\#, 
Dafny, SPARK, and to some limited extent Scala. Java supports 
contracts through JML, which, however, is not integrated with Java, 
but an add-on comment language (JML specifications are comments in 
a Java program). Most of the languages above support abstract 
collections such as sets, lists and maps. It is interesting to 
observe that SUN’s Fortress language (which unfortunately was not 
finished due to lack of funding) supports a mathematical 
notation for collections very similar to VDM. The systems 
Dafny and Why3 are amongst the newest branches of work, 
interesting since these languages are developed 
specifically with verification in mind.A trend on the rise is the combination of object-oriented 
and functional programming, as seen in perhaps most prominently 
Scala, but also in the earlier Python, and now in Java which got 
closures in version 1.8.  Ocaml is a similar earlier attempt to 
integrate object-oriented and functional programming, although in a 
layered manner, and not integrated with the standard module system. 
As in many other aspects, Lisp was early out
with this combination with the Common Lisp Object System (CLOS).
Some interesting new directions of research include dependent types 
as found in Agda (to some extent related to predicate subtypes in 
VDM) and session types. Session types are temporal patterns that 
can be checked at compile time. They are much related to temporal 
logic as used within the formal methods community to express 
properties of concurrent programs. At the same time there are also 
attempts to make more conservative moves away from C, but without 
losing too much efficiency. Examples include the languages Go, D and RUST. However, as stated earlier, C has an impressive staying power, and these attempts have not yet made the highway.

